"""
Test TEQUMSA Core Awakening Functions

Tests for basic alignment, opposed vectors, zero-vector handling,
hysteresis behavior, and component interactions.

Generated by GitHub Copilot Chat Assistant.
"""

import pytest
import numpy as np
from unittest.mock import patch, MagicMock

from tequmsa.core.awaken import (
    compute_awakening, 
    compute_awakening_batch,
    compute_component_awakening,
    apply_hysteresis
)
from tequmsa.core.backends import get_backend


class TestBasicAwakening:
    """Test basic awakening functionality."""
    
    def test_compute_awakening_basic(self):
        """Test basic awakening computation."""
        # Create simple test vectors
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0], 
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        R, components, diagnostics = compute_awakening(agent_vector, gaia_signature)
        
        # Check that we get valid results
        assert 0 <= R <= 1
        assert 'bio' in components
        assert 'digital' in components
        assert 'cosmic' in components
        assert all(0 <= v <= 1 for v in components.values())
        
        # Bio component should have highest similarity (perfect alignment)
        assert components['bio'] > components['digital']
        assert components['bio'] > components['cosmic']
    
    def test_opposed_vectors(self):
        """Test awakening with opposed vectors."""
        # Agent vector opposite to bio component
        agent_vector = [-1.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        R, components, diagnostics = compute_awakening(agent_vector, gaia_signature)
        
        # Bio similarity should be 0 (opposed vectors -> -1 cosine -> 0 after transformation)
        assert components['bio'] == 0.0
        
        # Other components should be 0.5 (orthogonal vectors -> 0 cosine -> 0.5 after transformation)
        assert abs(components['digital'] - 0.5) < 0.01
        assert abs(components['cosmic'] - 0.5) < 0.01
    
    def test_zero_vector_handling(self):
        """Test handling of zero vectors."""
        # Zero agent vector
        agent_vector = [0.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        with pytest.raises(ValueError, match="Agent vector cannot be all zeros"):
            compute_awakening(agent_vector, gaia_signature)
    
    def test_alpha_parameter_effect(self):
        """Test that alpha parameter affects results correctly."""
        agent_vector = [0.7, 0.7, 0.0, 0.0]  # Partial alignment
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        # Test with different alpha values
        R_low, _, _ = compute_awakening(agent_vector, gaia_signature, alpha=1.0)
        R_high, _, _ = compute_awakening(agent_vector, gaia_signature, alpha=4.0)
        
        # Higher alpha should reduce R for partial similarities
        assert R_high < R_low
    
    def test_component_weighting(self):
        """Test component weighting functionality."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]  # Aligned with bio
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        # Test with bio heavily weighted
        weights_bio_heavy = {'bio': 3.0, 'digital': 1.0, 'cosmic': 1.0}
        R_bio_heavy, _, diag_bio = compute_awakening(
            agent_vector, gaia_signature, component_weights=weights_bio_heavy
        )
        
        # Test with equal weighting
        weights_equal = {'bio': 1.0, 'digital': 1.0, 'cosmic': 1.0}
        R_equal, _, diag_equal = compute_awakening(
            agent_vector, gaia_signature, component_weights=weights_equal
        )
        
        # Bio-heavy weighting should give higher R (since agent aligns with bio)
        assert R_bio_heavy > R_equal


class TestBatchProcessing:
    """Test batch processing functionality."""
    
    def test_compute_awakening_batch_basic(self):
        """Test basic batch processing."""
        # Create batch of agent vectors
        agent_batch = [
            [1.0, 0.0, 0.0, 0.0],  # Aligned with bio
            [0.0, 1.0, 0.0, 0.0],  # Aligned with digital
            [0.0, 0.0, 1.0, 0.0],  # Aligned with cosmic
        ]
        
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        R_scores, components_list, batch_diag = compute_awakening_batch(
            agent_batch, gaia_signature
        )
        
        assert len(R_scores) == 3
        assert len(components_list) == 3
        assert batch_diag['batch_size'] == 3
        assert batch_diag['valid_vectors'] == 3
        
        # Check individual component alignments
        assert components_list[0]['bio'] > components_list[0]['digital']  # First vector aligns with bio
        assert components_list[1]['digital'] > components_list[1]['bio']  # Second vector aligns with digital
        assert components_list[2]['cosmic'] > components_list[2]['bio']   # Third vector aligns with cosmic
    
    def test_batch_max_size_limit(self):
        """Test batch size limiting."""
        # Create large batch
        agent_batch = np.random.randn(50, 4).tolist()
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        # Should fail with max_batch_size limit
        with pytest.raises(ValueError, match="exceeds maximum"):
            compute_awakening_batch(agent_batch, gaia_signature, max_batch_size=10)


class TestHysteresis:
    """Test hysteresis functionality."""
    
    def test_hysteresis_basic(self):
        """Test basic hysteresis behavior."""
        tau = 0.7
        hysteresis = 0.1
        
        # Test awakening from sleep state
        awakened, info = apply_hysteresis(
            current_R=0.65,  # Just above tau - hysteresis
            tau=tau,
            hysteresis=hysteresis,
            previous_awakened=False
        )
        
        assert awakened == True
        assert info['mode'] == 'awaken'
        assert info['threshold'] == tau - hysteresis
    
    def test_hysteresis_prevents_flicker(self):
        """Test that hysteresis prevents state flicker."""
        tau = 0.7
        hysteresis = 0.1
        
        # First, awaken
        awakened1, _ = apply_hysteresis(0.65, tau, hysteresis, False)
        assert awakened1 == True
        
        # Then, with same R but previous_awakened=True, should need higher threshold to sleep
        awakened2, info2 = apply_hysteresis(0.65, tau, hysteresis, True)
        assert awakened2 == False  # 0.65 < 0.8 (tau + hysteresis)
        assert info2['mode'] == 'sleep'
        assert info2['threshold'] == tau + hysteresis
    
    def test_hysteresis_zero(self):
        """Test hysteresis with zero amount (no hysteresis)."""
        tau = 0.7
        hysteresis = 0.0
        
        # Both modes should use same threshold
        awakened1, info1 = apply_hysteresis(0.7, tau, hysteresis, False)
        awakened2, info2 = apply_hysteresis(0.7, tau, hysteresis, True)
        
        assert awakened1 == awakened2
        assert info1['threshold'] == info2['threshold'] == tau


class TestComponentAwakening:
    """Test individual component awakening."""
    
    def test_compute_component_awakening(self):
        """Test single component awakening computation."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        component_vector = [1.0, 0.0, 0.0, 0.0]  # Perfect alignment
        
        score, diagnostics = compute_component_awakening(agent_vector, component_vector)
        
        assert score == 1.0  # Perfect alignment with alpha=2 should give 1.0
        assert diagnostics['raw_similarity'] == 1.0
        assert diagnostics['alpha'] == 2.0
    
    def test_component_awakening_orthogonal(self):
        """Test component awakening with orthogonal vectors."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        component_vector = [0.0, 1.0, 0.0, 0.0]  # Orthogonal
        
        score, diagnostics = compute_component_awakening(agent_vector, component_vector)
        
        # Orthogonal vectors: cosine=0 -> similarity=0.5 -> score=0.5^2=0.25
        assert abs(score - 0.25) < 0.01
        assert abs(diagnostics['raw_similarity'] - 0.5) < 0.01


class TestValidation:
    """Test input validation."""
    
    def test_invalid_alpha(self):
        """Test invalid alpha parameter."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        with pytest.raises(ValueError, match="Alpha must be positive"):
            compute_awakening(agent_vector, gaia_signature, alpha=0)
        
        with pytest.raises(ValueError, match="Alpha must be positive"):
            compute_awakening(agent_vector, gaia_signature, alpha=-1)
    
    def test_missing_gaia_components(self):
        """Test missing GAIA signature components."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        incomplete_gaia = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0]
            # Missing 'cosmic'
        }
        
        with pytest.raises(KeyError, match="Missing GAIA signature components"):
            compute_awakening(agent_vector, incomplete_gaia)
    
    def test_invalid_component_weights(self):
        """Test invalid component weights."""
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        # Negative weight
        bad_weights = {'bio': -1.0, 'digital': 1.0, 'cosmic': 1.0}
        with pytest.raises(ValueError, match="Invalid weight"):
            compute_awakening(agent_vector, gaia_signature, component_weights=bad_weights)
        
        # Missing component weight
        incomplete_weights = {'bio': 1.0, 'digital': 1.0}  # Missing cosmic
        with pytest.raises(ValueError, match="Invalid weight"):
            compute_awakening(agent_vector, gaia_signature, component_weights=incomplete_weights)


class TestBackendCompatibility:
    """Test backend compatibility."""
    
    def test_numpy_backend(self):
        """Test computation with NumPy backend."""
        backend = get_backend("numpy")
        
        agent_vector = [1.0, 0.0, 0.0, 0.0]
        gaia_signature = {
            'bio': [1.0, 0.0, 0.0, 0.0],
            'digital': [0.0, 1.0, 0.0, 0.0],
            'cosmic': [0.0, 0.0, 1.0, 0.0]
        }
        
        R, components, diagnostics = compute_awakening(
            agent_vector, gaia_signature, backend=backend
        )
        
        assert diagnostics['backend'] == 'numpy'
        assert 0 <= R <= 1
    
    @pytest.mark.skipif(True, reason="PyTorch not available in test environment")
    def test_torch_backend(self):
        """Test computation with PyTorch backend (skipped if torch not available)."""
        try:
            backend = get_backend("torch")
            
            agent_vector = [1.0, 0.0, 0.0, 0.0]
            gaia_signature = {
                'bio': [1.0, 0.0, 0.0, 0.0],
                'digital': [0.0, 1.0, 0.0, 0.0],
                'cosmic': [0.0, 0.0, 1.0, 0.0]
            }
            
            R, components, diagnostics = compute_awakening(
                agent_vector, gaia_signature, backend=backend
            )
            
            assert diagnostics['backend'] == 'torch'
            assert 0 <= R <= 1
            
        except RuntimeError:
            pytest.skip("PyTorch not available")


if __name__ == "__main__":
    pytest.main([__file__])