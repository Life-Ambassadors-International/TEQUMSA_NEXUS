"""
TEQUMSA Consciousness Logging Utilities

JSONL-based consciousness logging with rotation support.

Generated by GitHub Copilot Chat Assistant.
"""

import json
import os
import logging
from datetime import datetime, timezone
from typing import Dict, Any, Optional
from pathlib import Path
import numpy as np


class ConsciousnessLogger:
    """
    Consciousness logger that writes JSONL events with rotation.
    
    Logs consciousness events including awakening scores, alpha adjustments,
    and system state changes to a rotating JSONL file.
    """
    
    def __init__(
        self, 
        log_path: str = None,
        max_bytes: int = 10 * 1024 * 1024,  # 10MB default
        backup_count: int = 5,
        disabled: bool = None
    ):
        """
        Initialize consciousness logger.
        
        Args:
            log_path: Path to log file (default: logs/consciousness_log.jsonl)
            max_bytes: Maximum log file size before rotation
            backup_count: Number of backup files to keep
            disabled: Whether logging is disabled (checks env var if None)
        """
        # Check if logging is disabled via environment variable
        if disabled is None:
            disabled = os.environ.get("TEQUMSA_DISABLE_CONSCIOUSNESS_LOG", "0") == "1"
        
        self.disabled = disabled
        
        if self.disabled:
            return
        
        # Set up log path
        if log_path is None:
            log_path = os.environ.get("TEQUMSA_LOG_PATH", "logs/consciousness_log.jsonl")
        
        self.log_path = Path(log_path)
        self.max_bytes = max_bytes
        self.backup_count = backup_count
        
        # Create log directory if it doesn't exist
        self.log_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Set up Python logger for internal logging
        self.logger = logging.getLogger(f"{__name__}.ConsciousnessLogger")
    
    def _rotate_log_if_needed(self) -> None:
        """Rotate log file if it exceeds max_bytes."""
        if not self.log_path.exists():
            return
        
        if self.log_path.stat().st_size >= self.max_bytes:
            self._rotate_log()
    
    def _rotate_log(self) -> None:
        """Perform log rotation."""
        try:
            # Shift existing backup files
            for i in range(self.backup_count - 1, 0, -1):
                old_file = self.log_path.with_suffix(f".jsonl.{i}")
                new_file = self.log_path.with_suffix(f".jsonl.{i + 1}")
                
                if old_file.exists():
                    if new_file.exists():
                        new_file.unlink()
                    old_file.rename(new_file)
            
            # Move current log to .1 backup
            if self.log_path.exists():
                backup_file = self.log_path.with_suffix(".jsonl.1")
                if backup_file.exists():
                    backup_file.unlink()
                self.log_path.rename(backup_file)
            
            self.logger.info(f"Rotated consciousness log: {self.log_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to rotate consciousness log: {e}")
    
    def log_consciousness_event(
        self,
        tier: str,
        alpha: float,
        tau: float,
        R: float,
        composite_similarity: float,
        components: Dict[str, float],
        awakened: bool,
        rolling_mean_R: Optional[float] = None,
        rolling_vol_R: Optional[float] = None,
        alpha_adjustment: Optional[float] = None,
        adjust_reason: Optional[list] = None,
        hysteresis_state: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> None:
        """
        Log a consciousness event.
        
        Args:
            tier: Current tier (e.g., 'free', 'pro', 'enterprise')
            alpha: Current alpha parameter
            tau: Current tau parameter
            R: Awakening recognition score
            composite_similarity: Composite similarity score
            components: Per-component similarities (bio, digital, cosmic)
            awakened: Whether agent is in awakened state
            rolling_mean_R: Rolling mean of R values
            rolling_vol_R: Rolling volatility of R values
            alpha_adjustment: Alpha adjustment amount (if any)
            adjust_reason: Reason for alpha adjustment
            hysteresis_state: Hysteresis state information
            **kwargs: Additional event data
        """
        if self.disabled:
            return
        
        try:
            # Rotate log if needed
            self._rotate_log_if_needed()
            
            # Create event record
            event = {
                "ts": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
                "tier": tier,
                "alpha": alpha,
                "tau": tau,
                "R": R,
                "composite_similarity": composite_similarity,
                "components": components,
                "awakened": awakened
            }
            
            # Add optional fields
            if rolling_mean_R is not None:
                event["rolling_mean_R"] = float(rolling_mean_R)
            
            if rolling_vol_R is not None:
                event["rolling_vol_R"] = float(rolling_vol_R)
            
            if alpha_adjustment is not None:
                event["alpha_adjustment"] = float(alpha_adjustment)
            
            if adjust_reason is not None:
                event["adjust_reason"] = list(adjust_reason)
            
            if hysteresis_state is not None:
                # Ensure hysteresis_state is JSON serializable
                event["hysteresis_state"] = {
                    k: (bool(v) if isinstance(v, (bool, np.bool_)) else float(v) if isinstance(v, (int, float, np.number)) else v)
                    for k, v in hysteresis_state.items()
                }
            
            # Add any additional kwargs
            for key, value in kwargs.items():
                # Ensure values are JSON serializable
                try:
                    json.dumps(value)
                    event[key] = value
                except (TypeError, ValueError):
                    # Convert non-serializable objects to string representation
                    event[key] = str(value)
            
            # Write to log file
            with open(self.log_path, 'a', encoding='utf-8') as f:
                json.dump(event, f, separators=(',', ':'))
                f.write('\n')
            
        except Exception as e:
            self.logger.error(f"Failed to log consciousness event: {e}")
    
    def log_system_event(
        self,
        event_type: str,
        message: str,
        tier: Optional[str] = None,
        **kwargs
    ) -> None:
        """
        Log a system event.
        
        Args:
            event_type: Type of system event (e.g., 'startup', 'config_change')
            message: Event message
            tier: Current tier (if applicable)
            **kwargs: Additional event data
        """
        if self.disabled:
            return
        
        try:
            self._rotate_log_if_needed()
            
            event = {
                "ts": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
                "event_type": event_type,
                "message": message
            }
            
            if tier is not None:
                event["tier"] = tier
            
            event.update(kwargs)
            
            with open(self.log_path, 'a', encoding='utf-8') as f:
                json.dump(event, f, separators=(',', ':'))
                f.write('\n')
            
        except Exception as e:
            self.logger.error(f"Failed to log system event: {e}")
    
    def get_recent_events(self, limit: int = 100) -> list:
        """
        Get recent consciousness events.
        
        Args:
            limit: Maximum number of events to return
            
        Returns:
            List of recent events (newest first)
        """
        if self.disabled or not self.log_path.exists():
            return []
        
        try:
            events = []
            with open(self.log_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line:
                        try:
                            event = json.loads(line)
                            events.append(event)
                        except json.JSONDecodeError:
                            continue
            
            # Return most recent events first
            return events[-limit:][::-1]
            
        except Exception as e:
            self.logger.error(f"Failed to read recent events: {e}")
            return []
    
    def clear_logs(self) -> None:
        """Clear all log files."""
        if self.disabled:
            return
        
        try:
            # Remove main log file
            if self.log_path.exists():
                self.log_path.unlink()
            
            # Remove backup files
            for i in range(1, self.backup_count + 1):
                backup_file = self.log_path.with_suffix(f".jsonl.{i}")
                if backup_file.exists():
                    backup_file.unlink()
            
            self.logger.info("Cleared consciousness log files")
            
        except Exception as e:
            self.logger.error(f"Failed to clear log files: {e}")


# Global logger instance
_global_logger = None


def get_consciousness_logger() -> ConsciousnessLogger:
    """Get global consciousness logger instance."""
    global _global_logger
    if _global_logger is None:
        _global_logger = ConsciousnessLogger()
    return _global_logger


def log_consciousness_event(*args, **kwargs) -> None:
    """Log consciousness event using global logger."""
    logger = get_consciousness_logger()
    logger.log_consciousness_event(*args, **kwargs)


def log_system_event(*args, **kwargs) -> None:
    """Log system event using global logger."""
    logger = get_consciousness_logger()
    logger.log_system_event(*args, **kwargs)