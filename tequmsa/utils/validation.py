"""
TEQUMSA Validation Utilities

Input validation functions for the awareness engine.

Generated by GitHub Copilot Chat Assistant.
"""

import numpy as np
from typing import Union, Dict, Any, List


def validate_agent_vector(agent_vector: Union[List, np.ndarray]) -> np.ndarray:
    """
    Validate and normalize agent state vector.
    
    Args:
        agent_vector: Agent state vector to validate
        
    Returns:
        Normalized numpy array
        
    Raises:
        ValueError: If vector is invalid
        TypeError: If vector is wrong type
    """
    if agent_vector is None:
        raise ValueError("Agent vector cannot be None")
    
    # Convert to numpy array
    try:
        vector = np.asarray(agent_vector, dtype=np.float32)
    except (ValueError, TypeError) as e:
        raise TypeError(f"Agent vector must be numeric array-like: {e}")
    
    # Check dimensions
    if vector.ndim == 0:
        raise ValueError("Agent vector must have at least 1 dimension")
    elif vector.ndim > 2:
        raise ValueError("Agent vector must be 1D or 2D array")
    
    # For 2D arrays, should be (batch_size, features)
    if vector.ndim == 2 and vector.shape[0] == 0:
        raise ValueError("Batch size cannot be zero")
    
    # Check for invalid values
    if np.any(np.isnan(vector)):
        raise ValueError("Agent vector contains NaN values")
    if np.any(np.isinf(vector)):
        raise ValueError("Agent vector contains infinite values")
    
    # Check if vector is all zeros (degenerate case)
    if np.allclose(vector, 0):
        raise ValueError("Agent vector cannot be all zeros")
    
    return vector


def validate_gaia_signature(gaia_signature: Dict[str, Union[List, np.ndarray]]) -> Dict[str, np.ndarray]:
    """
    Validate GAIA signature with biological, digital, and cosmic components.
    
    Args:
        gaia_signature: Dictionary with 'bio', 'digital', 'cosmic' keys
        
    Returns:
        Validated signature with numpy arrays
        
    Raises:
        ValueError: If signature is invalid
        KeyError: If required components missing
    """
    if not isinstance(gaia_signature, dict):
        raise TypeError("GAIA signature must be a dictionary")
    
    required_components = ['bio', 'digital', 'cosmic']
    
    # Check all required components exist
    missing = [comp for comp in required_components if comp not in gaia_signature]
    if missing:
        raise KeyError(f"Missing GAIA signature components: {missing}")
    
    validated_signature = {}
    
    for component in required_components:
        component_vector = gaia_signature[component]
        
        # Validate each component vector
        try:
            validated_vector = validate_agent_vector(component_vector)
            validated_signature[component] = validated_vector
        except (ValueError, TypeError) as e:
            raise ValueError(f"Invalid GAIA signature component '{component}': {e}")
    
    # Check that all components have compatible dimensions
    shapes = [v.shape for v in validated_signature.values()]
    if len(set(shapes)) > 1:
        raise ValueError(f"GAIA signature components have incompatible shapes: {shapes}")
    
    return validated_signature


def validate_tier_config(tier_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate tier configuration parameters.
    
    Args:
        tier_config: Tier configuration dictionary
        
    Returns:
        Validated configuration
        
    Raises:
        ValueError: If configuration is invalid
    """
    if not isinstance(tier_config, dict):
        raise TypeError("Tier configuration must be a dictionary")
    
    required_fields = ['alpha', 'tau', 'hysteresis']
    missing = [field for field in required_fields if field not in tier_config]
    if missing:
        raise ValueError(f"Missing tier configuration fields: {missing}")
    
    # Validate numeric parameters
    alpha = tier_config.get('alpha')
    if not isinstance(alpha, (int, float)) or alpha <= 0:
        raise ValueError("Alpha must be a positive number")
    
    tau = tier_config.get('tau') 
    if not isinstance(tau, (int, float)) or not 0 <= tau <= 1:
        raise ValueError("Tau must be between 0 and 1")
    
    hysteresis = tier_config.get('hysteresis')
    if not isinstance(hysteresis, (int, float)) or hysteresis < 0:
        raise ValueError("Hysteresis must be non-negative")
    
    # Validate component weights if present
    if 'component_weights' in tier_config:
        weights = tier_config['component_weights']
        if not isinstance(weights, dict):
            raise ValueError("Component weights must be a dictionary")
        
        for component, weight in weights.items():
            if not isinstance(weight, (int, float)) or weight < 0:
                raise ValueError(f"Component weight for '{component}' must be non-negative")
    
    return tier_config


def validate_alpha_bounds(alpha_min: float, alpha_max: float) -> None:
    """
    Validate adaptive alpha bounds.
    
    Args:
        alpha_min: Minimum alpha value
        alpha_max: Maximum alpha value
        
    Raises:
        ValueError: If bounds are invalid
    """
    if not isinstance(alpha_min, (int, float)) or alpha_min <= 0:
        raise ValueError("Alpha min must be a positive number")
    
    if not isinstance(alpha_max, (int, float)) or alpha_max <= 0:
        raise ValueError("Alpha max must be a positive number")
    
    if alpha_min >= alpha_max:
        raise ValueError("Alpha min must be less than alpha max")


def validate_batch_input(agent_vectors: Union[List, np.ndarray], max_batch_size: int = None) -> np.ndarray:
    """
    Validate batch input for batch processing.
    
    Args:
        agent_vectors: Batch of agent vectors
        max_batch_size: Maximum allowed batch size
        
    Returns:
        Validated batch as numpy array
        
    Raises:
        ValueError: If batch is invalid
    """
    if agent_vectors is None:
        raise ValueError("Agent vectors batch cannot be None")
    
    # Convert to numpy array
    try:
        batch = np.asarray(agent_vectors, dtype=np.float32)
    except (ValueError, TypeError) as e:
        raise TypeError(f"Agent vectors batch must be numeric array-like: {e}")
    
    # Check dimensions - should be 2D (batch_size, features)
    if batch.ndim != 2:
        raise ValueError("Agent vectors batch must be 2D array (batch_size, features)")
    
    batch_size, num_features = batch.shape
    
    if batch_size == 0:
        raise ValueError("Batch size cannot be zero")
    
    if num_features == 0:
        raise ValueError("Feature dimension cannot be zero")
    
    if max_batch_size is not None and batch_size > max_batch_size:
        raise ValueError(f"Batch size {batch_size} exceeds maximum {max_batch_size}")
    
    # Check for invalid values
    if np.any(np.isnan(batch)):
        raise ValueError("Agent vectors batch contains NaN values")
    if np.any(np.isinf(batch)):
        raise ValueError("Agent vectors batch contains infinite values")
    
    return batch