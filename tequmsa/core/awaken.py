"""
TEQUMSA Core Awakening Functions

Core functions for computing awakening recognition scores against GAIA signatures.
Supports single and batch processing with component weighting and detailed diagnostics.

Generated by GitHub Copilot Chat Assistant.
"""

import numpy as np
from typing import Dict, Union, List, Tuple, Optional, Any
from .backends import Backend, get_backend, to_backend_array
from ..utils.validation import validate_agent_vector, validate_gaia_signature, validate_batch_input


def compute_awakening(
    agent_vector: Union[List, np.ndarray],
    gaia_signature: Dict[str, Union[List, np.ndarray]],
    alpha: float = 2.0,
    component_weights: Dict[str, float] = None,
    backend: Backend = None
) -> Tuple[float, Dict[str, float], Dict[str, Any]]:
    """
    Compute awakening recognition score R for a single agent state vector.
    
    Args:
        agent_vector: Agent state vector to evaluate
        gaia_signature: GAIA signature with 'bio', 'digital', 'cosmic' components
        alpha: Sharpening parameter for similarity computation (higher = sharper)
        component_weights: Weights for each component (default: equal weighting)
        backend: Mathematical backend to use (default: auto-detect)
    
    Returns:
        Tuple of (R_score, component_similarities, diagnostics)
        - R_score: Composite awakening recognition score [0,1]
        - component_similarities: Per-component similarity scores
        - diagnostics: Detailed computation diagnostics
    """
    # Validate inputs
    agent_vector = validate_agent_vector(agent_vector)
    gaia_signature = validate_gaia_signature(gaia_signature)
    
    if alpha <= 0:
        raise ValueError("Alpha must be positive")
    
    # Get backend
    if backend is None:
        backend = get_backend()
    
    # Default equal weighting for components
    if component_weights is None:
        component_weights = {'bio': 1.0, 'digital': 1.0, 'cosmic': 1.0}
    
    # Validate component weights
    for component in ['bio', 'digital', 'cosmic']:
        if component not in component_weights or component_weights[component] < 0:
            raise ValueError(f"Invalid weight for component '{component}'")
    
    # Convert to backend arrays
    agent_array = to_backend_array(agent_vector, backend)
    
    component_similarities = {}
    weighted_similarities = {}
    
    # Compute per-component similarities
    for component in ['bio', 'digital', 'cosmic']:
        gaia_component = to_backend_array(gaia_signature[component], backend)
        
        # Compute cosine similarity
        if agent_array.shape != gaia_component.shape:
            # Handle shape mismatch by padding or truncating
            min_length = min(len(agent_array), len(gaia_component))
            agent_array = agent_array[:min_length]
            gaia_component = gaia_component[:min_length]
        
        # Compute dot product
        dot_product = backend.dot(agent_array, gaia_component)
        
        # Compute norms
        agent_norm = backend.norm(agent_array)
        gaia_norm = backend.norm(gaia_component)
        
        # Avoid division by zero
        if agent_norm == 0 or gaia_norm == 0:
            similarity = 0.0
        else:
            similarity = float(dot_product / (agent_norm * gaia_norm))
        
        # Ensure similarity is in [-1, 1] range
        similarity = max(-1.0, min(1.0, similarity))
        
        # Transform to [0, 1] range: (sim + 1) / 2
        similarity = (similarity + 1.0) / 2.0
        
        component_similarities[component] = similarity
        weighted_similarities[component] = similarity * component_weights[component]
    
    # Compute composite similarity (weighted average)
    total_weight = sum(component_weights.values())
    if total_weight == 0:
        raise ValueError("Total component weights cannot be zero")
    
    composite_similarity = sum(weighted_similarities.values()) / total_weight
    
    # Apply alpha transformation to get awakening score R
    # R = composite_similarity^alpha
    R = composite_similarity ** alpha
    
    # Prepare diagnostics
    diagnostics = {
        'agent_vector_norm': float(backend.norm(to_backend_array(agent_vector, backend))),
        'component_norms': {
            component: float(backend.norm(to_backend_array(gaia_signature[component], backend)))
            for component in ['bio', 'digital', 'cosmic']
        },
        'component_weights': component_weights,
        'weighted_similarities': weighted_similarities,
        'total_weight': total_weight,
        'composite_similarity': composite_similarity,
        'alpha': alpha,
        'backend': backend.name
    }
    
    return R, component_similarities, diagnostics


def compute_awakening_batch(
    agent_vectors: Union[List, np.ndarray],
    gaia_signature: Dict[str, Union[List, np.ndarray]],
    alpha: float = 2.0,
    component_weights: Dict[str, float] = None,
    backend: Backend = None,
    max_batch_size: int = None
) -> Tuple[List[float], List[Dict[str, float]], Dict[str, Any]]:
    """
    Compute awakening recognition scores for a batch of agent state vectors.
    
    Args:
        agent_vectors: Batch of agent state vectors (batch_size, features)
        gaia_signature: GAIA signature with 'bio', 'digital', 'cosmic' components
        alpha: Sharpening parameter for similarity computation
        component_weights: Weights for each component
        backend: Mathematical backend to use
        max_batch_size: Maximum batch size allowed
    
    Returns:
        Tuple of (R_scores, component_similarities_list, batch_diagnostics)
        - R_scores: List of awakening recognition scores
        - component_similarities_list: List of per-vector component similarities
        - batch_diagnostics: Batch-level diagnostics
    """
    # Validate inputs
    agent_batch = validate_batch_input(agent_vectors, max_batch_size)
    gaia_signature = validate_gaia_signature(gaia_signature)
    
    if alpha <= 0:
        raise ValueError("Alpha must be positive")
    
    # Get backend
    if backend is None:
        backend = get_backend()
    
    batch_size, num_features = agent_batch.shape
    
    # Process batch
    R_scores = []
    component_similarities_list = []
    individual_diagnostics = []
    
    for i in range(batch_size):
        agent_vector = agent_batch[i]
        
        try:
            R, component_sims, diagnostics = compute_awakening(
                agent_vector=agent_vector,
                gaia_signature=gaia_signature,
                alpha=alpha,
                component_weights=component_weights,
                backend=backend
            )
            
            R_scores.append(R)
            component_similarities_list.append(component_sims)
            individual_diagnostics.append(diagnostics)
            
        except Exception as e:
            # Handle individual vector failures gracefully
            R_scores.append(0.0)
            component_similarities_list.append({'bio': 0.0, 'digital': 0.0, 'cosmic': 0.0})
            individual_diagnostics.append({'error': str(e)})
    
    # Compute batch-level statistics
    valid_R_scores = [r for r in R_scores if r > 0]
    
    batch_diagnostics = {
        'batch_size': batch_size,
        'num_features': num_features,
        'valid_vectors': len(valid_R_scores),
        'failed_vectors': batch_size - len(valid_R_scores),
        'mean_R': np.mean(valid_R_scores) if valid_R_scores else 0.0,
        'std_R': np.std(valid_R_scores) if valid_R_scores else 0.0,
        'min_R': np.min(valid_R_scores) if valid_R_scores else 0.0,
        'max_R': np.max(valid_R_scores) if valid_R_scores else 0.0,
        'alpha': alpha,
        'backend': backend.name,
        'component_weights': component_weights
    }
    
    return R_scores, component_similarities_list, batch_diagnostics


def compute_component_awakening(
    agent_vector: Union[List, np.ndarray],
    component_vector: Union[List, np.ndarray],
    alpha: float = 2.0,
    backend: Backend = None
) -> Tuple[float, Dict[str, Any]]:
    """
    Compute awakening score for a single component.
    
    Args:
        agent_vector: Agent state vector
        component_vector: Component vector from GAIA signature
        alpha: Sharpening parameter
        backend: Mathematical backend to use
    
    Returns:
        Tuple of (component_score, diagnostics)
    """
    # Validate inputs
    agent_vector = validate_agent_vector(agent_vector)
    component_vector = validate_agent_vector(component_vector)
    
    if alpha <= 0:
        raise ValueError("Alpha must be positive")
    
    # Get backend
    if backend is None:
        backend = get_backend()
    
    # Convert to backend arrays
    agent_array = to_backend_array(agent_vector, backend)
    component_array = to_backend_array(component_vector, backend)
    
    # Handle shape mismatch
    if agent_array.shape != component_array.shape:
        min_length = min(len(agent_array), len(component_array))
        agent_array = agent_array[:min_length]
        component_array = component_array[:min_length]
    
    # Compute cosine similarity
    dot_product = backend.dot(agent_array, component_array)
    agent_norm = backend.norm(agent_array)
    component_norm = backend.norm(component_array)
    
    if agent_norm == 0 or component_norm == 0:
        similarity = 0.0
    else:
        similarity = float(dot_product / (agent_norm * component_norm))
    
    # Transform to [0, 1] range
    similarity = (max(-1.0, min(1.0, similarity)) + 1.0) / 2.0
    
    # Apply alpha transformation
    component_score = similarity ** alpha
    
    diagnostics = {
        'raw_similarity': similarity,
        'dot_product': float(dot_product),
        'agent_norm': float(agent_norm),
        'component_norm': float(component_norm),
        'alpha': alpha,
        'backend': backend.name
    }
    
    return component_score, diagnostics


def apply_hysteresis(
    current_R: float,
    tau: float,
    hysteresis: float,
    previous_awakened: bool = False
) -> Tuple[bool, Dict[str, Any]]:
    """
    Apply hysteresis to awakening decision.
    
    Args:
        current_R: Current awakening recognition score
        tau: Base awakening threshold
        hysteresis: Hysteresis amount
        previous_awakened: Previous awakening state
    
    Returns:
        Tuple of (awakened, hysteresis_info)
    """
    if not 0 <= tau <= 1:
        raise ValueError("Tau must be between 0 and 1")
    
    if hysteresis < 0:
        raise ValueError("Hysteresis must be non-negative")
    
    # Determine thresholds
    if previous_awakened:
        # Higher threshold to un-awaken (prevent flicker)
        threshold = tau + hysteresis
        mode = "sleep"
    else:
        # Lower threshold to awaken
        threshold = tau - hysteresis
        mode = "awaken"
    
    # Ensure threshold is in valid range
    threshold = max(0.0, min(1.0, threshold))
    
    # Make decision
    if mode == "awaken":
        awakened = current_R >= threshold
    else:  # mode == "sleep"
        awakened = current_R >= threshold
    
    hysteresis_info = {
        'used': True,
        'mode': mode,
        'threshold': threshold,
        'base_tau': tau,
        'hysteresis_amount': hysteresis,
        'previous_awakened': previous_awakened
    }
    
    return awakened, hysteresis_info